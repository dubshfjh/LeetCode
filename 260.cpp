我们知道如果一个数组中只有一个元素是出现一次，其他元素是出现两次的解题思路。只需要把所有的元素异或之后，那么异或的结果就是那个最终的单个的元素。
    这个思路很简单，就是把每个数理解为对应的二进制位，那么那些出现两次的元素，他们在1出现的所有位置，1都出现两次，异或完就还是0。
    而对于那个单出现一次得元素，它每个二进制位对应的数字出现一次。所以最终的异或结果就相当于把出现两次的元素全部去除。 

有了上面的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个singleNumber元素出现一次，其余元素都出现两次。
    那么使用这种方法就可以找出这两个元素了。
    不妨假设这两个元素是x，y,而且x!=y，那么最终所有的元素异或的结果就是res = x^y.很显然，res!= 0，如果res=0，那么x=y，与题意不符。
    既然res！=0，那么我们可以找出其二进制表示中的"任意一个1"。对于原来的数组nums[i]，
    我们可以根据这个位置"取0/取1"就可以将数组分成Group1(该位置取"1")和Group2(该位置取"0")。
        对于x，y：由于 x^y 在该位置取1，说明x和y在该位置取值一个为0，一个为1,所以 x，y 属于不同的Group
        对于出现了2次的任意元素 a ：因为a的2次出现在该位置的取值必然相同，属于a的2次出现必然属于同一个Group
    最后，对Group1中的所有元素遍历异或 得到 x,y 中的其中1个(因为Group1和Group2中除了一个SingleNumber，都是成对出现的元素)；然后对Group2异或得到x,y的另一个

由于选择"x ^ y"的任意一个"1"都能解决问题，所以可以通过技巧性的位运算极快地找到"x^y中最右侧的1"   
    记 diff = x^y，设diff中最右侧的"1"位置为i 。-diff取值：(diff中每位取反)+1。而(diff每位取反)在{i,i+1,...}取值为{0,1,1,...1}
    因此(-diff)在{i,i+1,...}取值为{1,0,0,...,0}，在{0,2,...,i-1}取值为{~diff[0],~diff[1],...,~diff[i-1]}
    从而 (diff & -diff)在{0,...,i,...}取值为{0,0...1,0....}，
最后通过(diff & -diff) & nums[i] = 0/1<<i 就将出现了2次的元素，以及singleNumber x和y分成了Group1 和Group2

class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int diff = 0;
        for(int i=0;i<nums.size();i++){
            diff ^= nums[i];
        }
        diff = diff & (-diff);

        vector<int> res  = {0,0};
        for(int i=0;i<nums.size();i++){
            if(nums[i] & diff == 0){
                res[0] ^= nums[i];
            }
            else{//nums[i] & diff == 0...010...0
                res[1] ^= nums[i];
            }
        }
        return res;
    }
};
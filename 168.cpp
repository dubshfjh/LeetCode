52=2*26 ->"AZ"；1=0*26+1 -> 'A'；26=0*26+26 -> "Z"；27=1*26+1 -> "AA"； 53=2*26+1 -> "BA"；79=3*26+1 -> "CA"
拥有"26"这个数字的26进制转换问题(类比：每bit取值范围包括"10"的十进制)，使用递归思想分析：对于每一轮的n用temp记录(n%26)，1.递归终止条件为n==0 2.如果temp==0，说明本轮字母为'Z'，下一轮计算(n-26)/26得到str，返回str+'Z'
3. 如果temp!=0，说明本轮为'1-25' 对应字母 'A-Y'，下一轮计算(n-temp)/26得到tempstr，返回tempstr+'Z'
class Solution {
public:
    string convertToTitle(int n) {//本质上就是将n转换为存在26这个数字表示方式的特殊26进制，'1-26'用字母'A'to'Z'表示，但是真正的26进制中只存在{0-25}的表示方式
        int temp;
        char ch_temp;
        string res;
        //char temp = 'A'+n-1;//'0'=48，'1'=49,'A'=65,'a'=97.要将数字1-26对应到A-Z，以'A'为基准，则需要通过'A'+(num-1)将num转换
        //cout<<temp<<endl;//如果以'1'为基准，则'1'+('A'-'1')='A'，即字符'1'+(字符'A'与字符'1'的间距)。此时num的转换为'1'+('A'-'1')+(num-1)，实际上就是'A'+(num-1)
        
        if(n == 0){
            return res;
        }
        //n = a1*26^0 + a2*26^1 + a3*26^2 + ... +an*26^(n-1) = a0 +26(a1+26a2 ...因此a0通过(n mod 26)计算，a1 通过(n-a0)mod(26^2)来计算, ai 通过(n-...)mod(26^i+1)来计算
        temp = n%26;
        if(temp != 0){//当ai+1!=0时，即当前的n = a*26+b时，本层ai=b=当前的n mod 26,下层递归使用a，即(当前的n - temp)/26计算更高位
            ch_temp = 'A'+(temp-1);
            res = convertToTitle((n-temp)/26) + ch_temp;//此时本层ai取值范围为{1...25}
        }
        else{//当前的n = a*26时，本层ai = 26，即'Z'，下层递归使用a-1，即(当前的n - 26)/26 计算更高位
            res = convertToTitle((n-26)/26) + 'Z';
        }
        return res;
    }
};`